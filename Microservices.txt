Microservices

Types of Service Discovery
There are two types of Service Discovery

Client-Side Service Discovery
Server-Side Service Discovery
Point to Remember:

Client-Side Service Discovery Example: Netflix Eureka, Zookeeper, Consul
Server-Side Service Discovery Example: NGNIX, AWS ELB

AWS ELB: https://aws.amazon.com/elasticloadbalancing/


nginx [engine x] is an HTTP and reverse proxy server, a mail proxy server, and a generic TCP/UDP proxy server,
NGNIX :https://www.nginx.com/


Comparison: API Gateway vs. Load Balancer
So, how do API gateways and load balancers differ? 
The main difference between these two services is that API gateways provide secure access to backend services, 
whereas load balancers distribute traffic between multiple servers. In short, 
a load balancer API distributes incoming requests while an API gateway authenticates and provides access to data sources or other applications.

When deciding which option is best suited for your application, you'll need to consider the following factors:

Functionality - Does your application need authentication or rate-limiting? If so, an API gateway may be the better choice.

Performance ‚Äì How many loads will your application be expected to handle? A load balancer may be the better option 
if you need to distribute traffic across multiple servers.

Cost ‚Äì API gateways are generally more expensive than load balancers, so budget is also a factor to consider.




########################################################################
Design Patterns

CQRS:
The command query responsibility segregation (CQRS) pattern separates the data mutation, or the command part of a system, from the query part. You can use the CQRS pattern to separate updates and queries if they have different requirements for throughput, latency, or consistency.





Circuit Breaker:

Why We Need Circuit Breaker Pattern?
assume that there are 2 microservices named user and article. When the user service needs to communicate 
with the article service, it creates a new thread and sends a request to the article service. However, 
if there are any network issues or timeout failures from the article service, the user service will not 
get an instant response. Also, there is no way to inform the user service about the failure so it will wait 
for a response. As a result, the user service will send continuous requests to the article service until 
its resources are exhausted, resulting in user service failure.


It has three states: Closed, Open, and Half Open.


https://www.youtube.com/watch?v=b6R4dElDtRc&ab_channel=JavaTechie

https://blog.bitsrc.io/circuit-breaker-pattern-in-microservices-26bf6e5b21ff#:~:text=Understanding%20and%20implementing%20the%20circuit,%2C%20Open%2C%20and%20Half%20Open.
https://github.com/spring-guides/gs-cloud-circuit-breaker




Orchestration :

Decision logic should be centarilized


Chereography
make it event driven


###########################################################

Transitioning from a **monolithic architecture** to **microservices** is a major shift that can dramatically improve scalability, maintainability, and deployment flexibility‚Äîbut it must be done thoughtfully. Here's a roadmap to guide you through the process:

---

## üß± Step-by-Step Migration Strategy

### 1. **Understand Your Monolith**
- Map out all modules, dependencies, and data flows.
- Identify tightly coupled components and shared resources.
- Use tools like static code analyzers or service maps to visualize complexity.

### 2. **Define Microservice Boundaries**
- Break down the monolith by **business capabilities** (e.g., User Management, Orders, Payments).
- Each microservice should own its **data**, logic, and API.
- Apply **Domain-Driven Design (DDD)** to identify bounded contexts.

### 3. **Start with a Strangler Pattern**
- Gradually replace parts of the monolith with microservices.
- Route specific functionality (e.g., authentication) to a new service while keeping the rest in the monolith.

### 4. **Extract and Build Microservices**
- Choose a small, low-risk module to extract first.
- Build it as an independent service with its own database.
- Use REST, gRPC, or messaging (Kafka, RabbitMQ) for communication.

### 5. **Implement API Gateway**
- Centralize routing, authentication, rate limiting, and logging.
- Tools: **Kong**, **NGINX**, **AWS API Gateway**, **Istio** (for service mesh).

### 6. **Decouple the Database**
- Avoid shared databases across services.
- Use **event-driven architecture** or **data replication** for cross-service data needs.

### 7. **Handle Cross-Cutting Concerns**
- Logging: Use centralized logging (e.g., ELK stack).
- Monitoring: Prometheus + Grafana, or tools like Datadog.
- Security: OAuth2, JWT, and service-to-service authentication.

### 8. **Automate CI/CD**
- Each microservice should have its own pipeline.
- Use containers (Docker) and orchestration (Kubernetes) for deployment.

### 9. **Test Thoroughly**
- Unit tests for each service.
- Integration tests for service interactions.
- Contract testing (e.g., Pact) to ensure API compatibility.

### 10. **Scale and Optimize**
- Monitor performance and scale services independently.
- Use horizontal scaling, autoscaling groups, and load balancers.

---

## üß™ Example: Breaking Out a User Service

From monolith:
```java
public class UserController {
    public User getUser(Long id) { ... }
    public void createUser(User user) { ... }
}
```

To microservice:
- Create a `UserService` with its own DB.
- Expose endpoints: `/users`, `/users/{id}`
- Deploy independently, e.g., on Kubernetes.

---
###############################

Here's a clear breakdown of the **difference between monolithic and microservices architectures**, along with their **advantages and disadvantages**:

---

## üß± Monolithic Architecture

### üîç Definition
A single unified application where all components (UI, business logic, data access) are tightly coupled and run as one process.

### ‚úÖ Advantages
- **Simplicity**: Easier to develop, test, and deploy initially.
- **Performance**: No overhead from inter-service communication.
- **Centralized management**: One codebase, one deployment pipeline.

### ‚ùå Disadvantages
- **Scalability limits**: Hard to scale individual components independently.
- **Tight coupling**: Changes in one part can affect the whole system.
- **Slow deployments**: Even small changes require redeploying the entire app.
- **Technology lock-in**: Difficult to adopt new tech stacks for specific modules.

---

## üß© Microservices Architecture

### üîç Definition
An application is broken into independent services, each responsible for a specific business capability, communicating via APIs.

### ‚úÖ Advantages
- **Scalability**: Services can be scaled independently based on demand.
- **Flexibility**: Teams can use different tech stacks per service.
- **Faster deployments**: Services can be deployed independently.
- **Resilience**: Failure in one service doesn‚Äôt crash the entire system.

### ‚ùå Disadvantages
- **Complexity**: Requires orchestration, service discovery, and API management.
- **Data consistency**: Harder to maintain ACID properties across services.
- **Operational overhead**: More moving parts to monitor, log, and secure.
- **Latency**: Network calls between services can slow down performance.

---

## üÜö Summary Table

| Feature                  | Monolithic                          | Microservices                         |
|--------------------------|--------------------------------------|----------------------------------------|
| Structure                | Single codebase                     | Multiple independent services          |
| Deployment               | One unit                            | Independent per service                |
| Scalability              | Whole app                           | Per service                            |
| Technology flexibility   | Limited                             | High                                   |
| Fault isolation          | Low                                 | High                                   |
| Development speed        | Fast initially                      | Slower setup, faster long-term         |
| Testing                  | Easier unit testing                 | Complex integration testing            |
| Maintenance              | Harder as app grows                 | Easier with modular services           |

---

Would you like help deciding which architecture suits your project or team best? 
I can help you evaluate based on your goals, team size, and tech stack.
