In Spring Boot, you can configure your application using a YAML (YAML Ain't Markup Language) file instead of a traditional properties file. YAML is a human-readable data serialization format that is commonly used for configuration files.

To define properties in a YAML file for your Spring Boot application, you typically create a file named `application.yml` or `application.yaml` in your application's `src/main/resources` directory. Here's an example of how you can define properties in a YAML file:

########################################################


```yaml
server:
  port: 8080

spring:
  datasource:
    url: jdbc:mysql://localhost:3306/mydb
    username: root
    password: password
  jpa:
    show-sql: true
    hibernate:
      ddl-auto: update
  profiles:
    active: dev
	
```


###########################################################

In this example, we have defined several properties under different sections:

- The `server` section configures the embedded web server and sets the port to `8080`.
- The `spring.datasource` section configures the database connection with the URL, username, and password.
- The `spring.jpa` section configures the JPA settings, such as showing SQL queries and specifying the Hibernate dialect and behavior.
- The `spring.profiles` section sets the active profile to `dev`.

You can define nested properties using indentation, as shown in the example. Be mindful of the spacing and indentation, as YAML relies on proper indentation for defining the hierarchy of properties.

Once you have defined your properties in the YAML file, Spring Boot will automatically load them and make them available for your application. You can access these properties using the `@Value` annotation or by injecting the `Environment` bean in your application code.

Note that you can still use a traditional `application.properties` file if you prefer that format. In that case, you would define your properties in a key-value format instead of using YAML syntax.


#####################################

Two DAta sources

spring:
  datasource:
    todos:
      url: ...
      username: ...
      password: ...
      driverClassName: ...
    topics:
      url: ...
      username: ...
      password: ...
      driverClassName: 
	  
2Then we can create the data sources by using the DataSourceProperties objects:

@Bean
public DataSource todosDataSource() {
    return todosDataSourceProperties()
      .initializeDataSourceBuilder()
      .build();
}

@Bean
public DataSource topicsDataSource() {
    return topicsDataSourceProperties()
      .initializeDataSourceBuilder()
      .build();
}

3)When using Spring Data JDBC, we also need to configure one instance of JdbcTemplate for each DataSource:
@Bean
public JdbcTemplate todosJdbcTemplate(@Qualifier("todosDataSource") DataSource dataSource) {
    return new JdbcTemplate(dataSource);
}

@Bean
public JdbcTemplate topicsJdbcTemplate(@Qualifier("topicsDataSource") DataSource dataSource) {
    return new JdbcTemplate(dataSource);
}



















#########################################################################
To handle **two data sources** in a Spring Boot application, you need to define separate configurations for each database. This is common in microservices, ETL pipelines, or multi-tenant systems. Here's a step-by-step guide:

---

## üóÇÔ∏è 1. Define Properties in `application.yml` or `application.properties`

```yaml
spring:
  datasource:
    primary:
      url: jdbc:mysql://localhost:3306/db1
      username: root
      password: secret
      driver-class-name: com.mysql.cj.jdbc.Driver

  secondary:
    url: jdbc:mysql://localhost:3306/db2
    username: root
    password: secret
    driver-class-name: com.mysql.cj.jdbc.Driver
```

---

## ‚öôÔ∏è 2. Create Configuration Classes for Each Data Source

### ‚úÖ Primary Data Source

```java
@Configuration
@EnableTransactionManagement
@EnableJpaRepositories(
    basePackages = "com.example.repo.primary",
    entityManagerFactoryRef = "primaryEntityManagerFactory",
    transactionManagerRef = "primaryTransactionManager"
)
public class PrimaryDataSourceConfig {

    @Primary
    @Bean
    @ConfigurationProperties("spring.datasource.primary")
    public DataSourceProperties primaryDataSourceProperties() {
        return new DataSourceProperties();
    }

    @Primary
    @Bean
    public DataSource primaryDataSource() {
        return primaryDataSourceProperties().initializeDataSourceBuilder().build();
    }

    @Primary
    @Bean
    public LocalContainerEntityManagerFactoryBean primaryEntityManagerFactory(
        EntityManagerFactoryBuilder builder) {
        return builder
            .dataSource(primaryDataSource())
            .packages("com.example.model.primary")
            .persistenceUnit("primary")
            .build();
    }

    @Primary
    @Bean
    public PlatformTransactionManager primaryTransactionManager(
        @Qualifier("primaryEntityManagerFactory") EntityManagerFactory emf) {
        return new JpaTransactionManager(emf);
    }
}
```

### ‚úÖ Secondary Data Source

```java
@Configuration
@EnableTransactionManagement
@EnableJpaRepositories(
    basePackages = "com.example.repo.secondary",
    entityManagerFactoryRef = "secondaryEntityManagerFactory",
    transactionManagerRef = "secondaryTransactionManager"
)
public class SecondaryDataSourceConfig {

    @Bean
    @ConfigurationProperties("spring.datasource.secondary")
    public DataSourceProperties secondaryDataSourceProperties() {
        return new DataSourceProperties();
    }

    @Bean
    public DataSource secondaryDataSource() {
        return secondaryDataSourceProperties().initializeDataSourceBuilder().build();
    }

    @Bean
    public LocalContainerEntityManagerFactoryBean secondaryEntityManagerFactory(
        EntityManagerFactoryBuilder builder) {
        return builder
            .dataSource(secondaryDataSource())
            .packages("com.example.model.secondary")
            .persistenceUnit("secondary")
            .build();
    }

    @Bean
    public PlatformTransactionManager secondaryTransactionManager(
        @Qualifier("secondaryEntityManagerFactory") EntityManagerFactory emf) {
        return new JpaTransactionManager(emf);
    }
}
```

---

## üß† Key Points

- Use `@Primary` to mark the default data source.
- Use `@Qualifier` to inject the correct beans.
- Keep entity classes and repositories in separate packages for each data source.
- Each data source needs its own `EntityManagerFactory` and `TransactionManager`.

---

For a full working example, check out this [Baeldung guide on multiple data sources](https://www.baeldung.com/spring-boot-configure-multiple-datasources) or [GeeksforGeeks tutorial](https://www.geeksforgeeks.org/advance-java/configure-multiple-datasource-in-spring-boot-application/).

Would you like help setting up a demo project or integrating this with Spring Data JDBC instead of JPA?
